# Copyright (c) 2013 Shotgun Software Inc.
#
# CONFIDENTIAL AND PROPRIETARY
#
# This work is provided "AS IS" and subject to the Shotgun Pipeline Toolkit
# Source Code License included in this distribution package. See LICENSE.
# By accessing, using, copying or modifying this work you indicate your
# agreement to the Shotgun Pipeline Toolkit Source Code License. All rights
# not expressly granted therein are reserved by Shotgun Software Inc.

import os

from sgtk import Hook

import unreal


class BreakdownSceneOperations(Hook):
    """
    TODO: docstring
    Breakdown operations for Maya.

    This implementation handles detection of maya references and file texture nodes.
    """

    TK_PATH_TAG = "sgtk_path"

    def scan_scene(self):
        """
        The scan scene method is executed once at startup and its purpose is
        to analyze the current scene and return a list of references that are
        to be potentially operated on.

        The return data structure is a list of dictionaries. Each scene reference
        that is returned should be represented by a dictionary with three keys:

        - "node": The name of the 'node' that is to be operated on. Most DCCs have
          a concept of a node, path or some other way to address a particular
          object in the scene.
        - "type": The object type that this is. This is later passed to the
          update method so that it knows how to handle the object.
        - "path": Path on disk to the referenced object.

        Toolkit will scan the list of items, see if any of the objects matches
        any templates and try to determine if there is a more recent version
        available. Any such versions are then displayed in the UI as out of date.
        """

        refs = []
        # Parse Unreal Editor Assets
        # Foreach asset, call a private method to build the scene_item_dict (node, type, path)
        # Provide a default method, leaving the possibility of overrigding it (each studio its own workflow)
        for asset_path in unreal.EditorAssetLibrary.list_assets("/Game/"):
            scene_item_dict = self._build_scene_item_dict(asset_path)
            if not scene_item_dict:
                continue
            refs.append(scene_item_dict)


        # # first let's look at maya references
        # for ref in cmds.file(q=True, reference=True):
        #     node_name = cmds.referenceQuery(ref, referenceNode=True)
        #
        #     # get the path and make it platform dependent
        #     # (maya uses C:/style/paths)
        #     maya_path = cmds.referenceQuery(
        #         ref, filename=True, withoutCopyNumber=True
        #     ).replace("/", os.path.sep)
        #     refs.append({"node": node_name, "type": "reference", "path": maya_path})
        #
        # # now look at file texture nodes
        # for file_node in cmds.ls(l=True, type="file"):
        #     # ensure this is actually part of this scene and not referenced
        #     if cmds.referenceQuery(file_node, isNodeReferenced=True):
        #         # this is embedded in another reference, so don't include it in the breakdown
        #         continue
        #
        #     # get path and make it platform dependent (maya uses C:/style/paths)
        #     path = cmds.getAttr("%s.fileTextureName" % file_node).replace(
        #         "/", os.path.sep
        #     )
        #
        #     refs.append({"node": file_node, "type": "file", "path": path})

        return refs


    def _build_scene_item_dict(self, asset_path):
        """
        overridable
        returns item dict or None
        """

        asset = unreal.load_asset(asset_path)
        sgtk_path = unreal.EditorAssetLibrary.get_metadata_tag(asset, "sgtk_path")
        if not sgtk_path:
            self.logger.debug("Asset `{}` does not have the tag `{}`".format(
                asset.get_path_name(), self.TK_PATH_TAG
            ))
            return None

        scene_item_dict = {
            "node": asset.get_path_name(),
            "type": str(type(asset)),
            # Must be a path linked ot a template with a {version} key
            # (see tk-multi-breakdown/python/tk_multi_breakdown/breakdown.py)
            "path": sgtk_path,
        }

        return scene_item_dict


    def update(self, items):
        """
        Perform replacements given a number of scene items passed from the app.

        Once a selection has been performed in the main UI and the user clicks
        the update button, this method is called.

        The items parameter is a list of dictionaries on the same form as was
        generated by the scan_scene hook above. The path key now holds
        the that each node should be updated *to* rather than the current path.
        """
        return
        #
        # engine = self.parent.engine
        #
        # for i in items:
        #
        #     node = i["node"]
        #     node_type = i["type"]
        #     new_path = i["path"]
        #
        #     if node_type == "reference":
        #         # maya reference
        #         engine.log_debug(
        #             "Maya Reference %s: Updating to version %s" % (node, new_path)
        #         )
        #         cmds.file(new_path, loadReference=node)
        #
        #     elif node_type == "file":
        #         # file texture node
        #         engine.log_debug(
        #             "File Texture %s: Updating to version %s" % (node, new_path)
        #         )
        #         file_name = cmds.getAttr("%s.fileTextureName" % node)
        #         cmds.setAttr("%s.fileTextureName" % node, new_path, type="string")
